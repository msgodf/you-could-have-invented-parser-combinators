(ns parser-combinators.core-test
  (:require [clojure.test :refer :all]
            [parser-combinators.core :refer :all]))

(deftest test-lit
  (testing "When the parser succeeds on the input, it returns the same character"
    (is (= (let [input (ref {:sequence (seq "abcd")
                             :position 0})
                 parser (lit \a)]
             (parser input))
           \a)))
  (testing "When the parser fails on the input, it returns failure"
    (is (= (let [input (ref {:sequence (seq "abcd")
                             :position 0})
                 parser (lit \b)]
             (parser input))
           :failure))))

(deftest test-or-combinator
  (testing "Takes two functions generated by lit, and returns the first one that succeeds"
    (is (= (let [input (ref {:sequence (seq "abcd")
                             :position 0})
                 parser (p-or (lit \a) (lit \z))]
             (parser input))
           \a))
    (is (= (let [input (ref {:sequence (seq "abcd")
                             :position 0})
                 parser (p-or (lit \z) (lit \a))]
             (parser input))
           \a))))

(deftest test-and-combinator
  (testing "If both of them succeed it returns the string of both the characters joined together"
    (is (= (let [input (ref {:sequence (seq "abcd")
                             :position 0})
                 parser (p-and (lit \a) (lit \b))]
             (parser input))
           "ab")))
  (testing "If both of them succeed it advances the input position forward by two"
    (is (= (let [input (ref {:sequence (seq "abcd")
                             :position 0})
                 parser (p-and (lit \a) (lit \b))]
             (parser input)
             (:position @input))
           2)))
  (testing "If any of them fail, it fails and rewinds the input."
    (is (= (let [input (ref {:sequence (seq "abcd")
                             :position 0})
                 parser (p-and (lit \b) (lit \a))]
             (parser input))
           :failure))
    (is (= (let [input (ref {:sequence (seq "abcd")
                             :position 0})
                 parser (p-and (lit \b) (lit \a))]
             (parser input)
             (:position @input))
           0))))

#_(run-tests)
